{"componentChunkName":"component---src-templates-post-page-jsx","path":"/blog/wildfly-clustering","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Magellan - A clustering tutorial with WildFly, nginx, Scala(FX) and Gradle","date":"2016-01-03","description":null,"tags":["networking","clustering","wildfly","nginx","scala","scalafx","gradle","moondeploy","ejb","jndi","tutorial"]},"html":"<h2>Introduction</h2>\n<p><em>High availability</em> is an essential requirement for more and more websites:</p>\n<ul>\n<li>there should <em>not</em> be significant delays as the number of simultaneous requests increases</li>\n<li>in case of a hardware or software failure, the website should continue to work</li>\n<li>there should be a way to <em>dynamically adjust</em> the capabilities of the infrastructure</li>\n</ul>\n<p>From our WildFly-oriented point of view, a <strong>cluster</strong> can be defined as a set of server instances (<em>nodes</em>) that behave as a single network component serving requests; it effectively addresses the above issues:</p>\n<ul>\n<li>all the nodes in the cluster are equivalent and can reside on any machine; usually, a client is able to address <em>any node</em> and receive <em>the very same response</em>, thanks to <em>state replication</em></li>\n<li>should a node crash, the overall cluster <em>continues with its activity</em></li>\n<li><em>nodes can be dynamically added and removed</em>, according to the current requirements - for example, new instances can be introduced to support request peaks and shut down later</li>\n</ul>\n<p>In such a scenario, <strong>load balancing</strong> is a complementary tool, creating a sort of <em>network facade</em> making clustering totally transparent to clients - as they actually refer to a well-defined access point.</p>\n<p>This tutorial will guide us step by step - without any claim of completeness - through the setup of a cluster and the deployment and execution of <a href=\"https://github.com/giancosta86/magellan\">Magellan</a>, a simple, open source Java EE application consisting of:</p>\n<ul>\n<li>\n<p>a <em>Java Enterprise Archive</em> (<strong>ear</strong>), containing:</p>\n<ul>\n<li>a <em>web application</em> with a few <em>servlets</em></li>\n<li>an <em>EJB-jar</em> providing a <em>stateful EJB</em></li>\n</ul>\n</li>\n<li>a <em>JavaFX</em> rich client application</li>\n</ul>\n<p>While playing with clustering, we'll deal with a wide range of modern technologies:</p>\n<ul>\n<li><a href=\"http://wildfly.org/\">WildFly</a> 9, the latest stable version of the robust and advanced WildFly Java EE server - and the project has been tested with the upcoming WildFly 10 as well</li>\n<li>The beautiful <a href=\"http://scala-lang.org/\">Scala</a> language, which proved effective and a pleasure to use in the <a href=\"http://docs.oracle.com/javaee/\">Java EE</a> domain as well</li>\n<li><a href=\"http://www.oracle.com/technetwork/java/javase/overview/index.html\">Java JDK</a> 8, providing a rich ecosystem for a variety of languages and frameworks</li>\n<li>The concise and efficient <a href=\"http://nginx.org/\">nginx</a> server for load balancing</li>\n<li><a href=\"http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html\">JavaFX</a> - wrapped by the outstanding <a href=\"http://www.scalafx.org/\">ScalaFX</a> library - to create a rich client running in a Java SE virtual machine</li>\n<li><a href=\"http://gradle.org/\">Gradle</a>, to manage inter-project dependencies and produce a sophisticated enterprise artifact with just one click (or one command line) - without manually copying and assembling intermediate artifacts</li>\n<li><a href=\"https://github.com/giancosta86/moondeploy\">MoonDeploy</a>, to download and run the rich client application directly from the web browser</li>\n</ul>\n<p>Since we are working in the Java ecosystem, any OS supporting Java can be employed while following the suggested steps.</p>\n<h2>Standalone and domain clustering</h2>\n<p>With regard to clustering, WildFly supports two distinct <em>operating modes</em>:</p>\n<ul>\n<li><strong>standalone</strong>: each server instance is configured independently. Despite the easy inital setup, it requires dedicated deployment and configuration for <em>every</em> single enterprise artifact (applications, EJB-jars, WARs, JDBC drivers, ...) on <em>every</em> single WildFly instance</li>\n<li><strong>domain</strong>: the nodes share a common management interface - deployed artifacts and configuration are automatically replicated to every node in the cluster</li>\n</ul>\n<p>Despite the fundamental differences, both clustering modes support state replication; therefore, for the sake of simplicity, in this article we'll learn how to create a cluster of <em>two standalone servers</em> on the same machine - but several ideas and concepts apply to domains as well.</p>\n<h2>Creating a standalone cluster</h2>\n<p>First of all, we'll start two different instances (<em>nodes</em>) of WildFly:</p>\n<ol>\n<li>Download the latest stable version of WildFly from its <a href=\"http://wildfly.org/downloads/\">download page</a> and extract the zip twice, creating two identical directory trees - let's assume they are named <strong>wildfly-alpha</strong> and <strong>wildfly-beta</strong></li>\n<li>\n<p>In a terminal, <code class=\"language-text\">cd</code> to <strong>wildfly-alpha/bin</strong> and run the command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./standalone.sh -c standalone-ha.xml -u <span class=\"token number\">230.0</span>.0.4 -Djboss.node.name<span class=\"token operator\">=</span>alpha -Djboss.socket.binding.port-offset<span class=\"token operator\">=</span><span class=\"token number\">1</span></code></pre></div>\n<p>Where:</p>\n<ul>\n<li><code class=\"language-text\">-u</code> declares <em>the multicast address shared by all the server instances in the cluster</em></li>\n<li><code class=\"language-text\">-Djboss.node.name</code> introduces a <em>node name</em>; every server instance must have its <strong>unique</strong> node name</li>\n<li><code class=\"language-text\">-Djboss.socket.binding.port-offset</code> adds the given offset to every default port number defined by the server instance - especially convenient when starting multiple nodes on the same machine</li>\n</ul>\n</li>\n<li>\n<p>In another terminal (or, better, another terminal tab), <code class=\"language-text\">cd</code> to <strong>wildfly-beta/bin</strong> and run:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./standalone.sh -c standalone-ha.xml -u <span class=\"token number\">230.0</span>.0.4 -Djboss.node.name<span class=\"token operator\">=</span>beta -Djboss.socket.binding.port-offset<span class=\"token operator\">=</span><span class=\"token number\">2</span></code></pre></div>\n<p>Compared to the previous server invocation:</p>\n<ul>\n<li>The <em>multicast address</em> is the very same</li>\n<li>The <em>node name</em> and the <em>port offset</em> are different</li>\n</ul>\n</li>\n</ol>\n<p>The cluster is ready! To test its capabilities, we are going to deploy Magellan, our Java EE application.</p>\n<h2>Deploying Magellan</h2>\n<ol>\n<li>Download the <strong>.ear</strong> archive from the <a href=\"https://github.com/giancosta86/magellan/releases/latest\">latest release page</a></li>\n<li>Copy it to the <strong>standalone/deployments</strong> subdirectory, <em>for both WildFly instances</em></li>\n</ol>\n<p>Incidentally, please consider that Magellan is a standard Java Enterprise application, so it could be deployed to other Java EE servers, such as GlassFish, to study high availability.</p>\n<h2>Testing HTTP session replication</h2>\n<ol>\n<li>\n<p>Point your web browser to the following addresses:</p>\n<ul>\n<li><a href=\"http://localhost:8081/magellan\">http://localhost:8081/magellan</a></li>\n<li><a href=\"http://localhost:8082/magellan\">http://localhost:8082/magellan</a></li>\n</ul>\n</li>\n<li>By refreshing each page, you'll see an increment <em>of the very same counter</em> (stored in the replicated HTTP session)</li>\n</ol>\n<h2>The session-based servlet</h2>\n<p>You might wonder what special classes are employed by the servlet to achieve session replication: luckily, the answer is <em>none</em> - clustering is completely transparent to the source code of Java EE components.</p>\n<p>On the other hand, your web application <em>must</em> include the <code class=\"language-text\">&lt;distributable&gt;</code> tag in its <strong>web.xml</strong> descriptor: were it missing, both pages would see their counter <em>reset to 0</em> whenever you switch from one page to the other!</p>\n<h4>Reference files</h4>\n<ul>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-war/src/main/scala/info/gianlucacosta/clustering/magellan/web/SimpleSessionServlet.scala\">Servlet</a></li>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-war/src/main/webapp/WEB-INF/web.xml\">web.xml configuration file</a></li>\n</ul>\n<h2>Load balancing with nginx</h2>\n<p>While verifying that our virtual nodes compose a cluster, we noticed that contacting either of them is equivalent; however, an inconvenience arises: we <em>always</em> need to know their network address. Not only: should a node crash, we'd have to remember the address of the <em>other</em> node - and what if our cluster includes thousands of nodes?</p>\n<p><em>Load balancing</em> is the natural solution to the problem; a <em>load balancer</em> is a network component that:</p>\n<ul>\n<li>is generally <em>not</em> part of the cluster in terms of state replication, but actively interacts with it, defining a wider network unit</li>\n<li>listens onto a network address, which is <em>the only address referenced by the clients</em></li>\n<li>knows the network address of all the nodes in the cluster</li>\n<li>when a request arrives, delivers it to a node, according to a wide range of possible algorithms and parameters</li>\n</ul>\n<p>In other terms, a load balancer is fairly similar to the <em>Facade</em> design pattern in OOP sofware engineering.</p>\n<p>There are several kinds of load balancers:</p>\n<ul>\n<li>dedicated, hyper-optimized hardware</li>\n<li>dedicated software</li>\n<li>HTTP servers with modules for load balancing</li>\n</ul>\n<p>What's more, a few solutions also provide <em>replication</em>, not to make the load balancer a <em>single point of failure</em> - that is, if one of the load balancer components crashes, the balancer as a whole continues serving at the given address.</p>\n<p>In this tutorial, we'll employ <a href=\"http://nginx.org/\">nginx</a> - an elegant, minimalist and fast server, providing fine-grained load balancing with just a few lines of configuration; another idea could be <em>mod</em>cluster_, a module for Apache HTTP server dedicated to WildFly.</p>\n<p>The steps are quite straightforward:</p>\n<ol>\n<li>\n<p>Install nginx. It should be available as a binary package for most operating systems. On Linux, in particular, you can also:</p>\n<ol>\n<li>Download and extract the source code archive</li>\n<li>Open a terminal and <code class=\"language-text\">cd</code> to the extracted directory</li>\n<li>Run the usual set of commands:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./configure --prefix<span class=\"token operator\">=</span><span class=\"token string\">\"&lt;where you want to install nginx, for example <span class=\"token environment constant\">$HOME</span>/nginx>\"</span>\n\n<span class=\"token function\">make</span>\n\n<span class=\"token function\">make</span> <span class=\"token function\">install</span></code></pre></div>\n<ol>\n<li>Add its <strong>sbin</strong> directory to your <strong>PATH</strong> environment variable</li>\n</ol>\n</li>\n<li>Download the configuration file for our cluster topology, <strong>nginx-balancer.conf</strong>, from <a href=\"https://github.com/giancosta86/magellan/releases/latest\">Magellan's release files</a></li>\n<li>\n<p>Run:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">nginx -c <span class=\"token string\">\"&lt;path to the configuration file>\"</span></code></pre></div>\n</li>\n<li>Navigate to <a href=\"http://localhost:8080/magellan\">http://localhost:8080/magellan</a> and refresh the page a few times</li>\n<li>Turn off either WildFly server, and notice that the web application runs unaffected after refreshing the page</li>\n<li>Restart that instance and shut down the other - further page refreshes will continue showing increased values for the counter.</li>\n</ol>\n<h2>Creating a stateful session bean</h2>\n<p>Stateful session beans are transparently replicated; should you need to deploy them to less recent server versions, you can mark them via the <code class=\"language-text\">@Clustered</code> annotation and/or specific tags in the <strong>jboss-ejb3.xml</strong> descriptor.</p>\n<p>For consistency, we'll expand the \"counter\" example by implementing a basic EJB counter, in <strong>magellan-ejb</strong>.</p>\n<h4>Reference files</h4>\n<ul>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-ejb/src/main/scala/info/gianlucacosta/clustering/magellan/ejb/CounterBean.scala\">Stateful EJB</a></li>\n</ul>\n<h2>Connecting to the EJB from the web tier</h2>\n<p>Now, we want to create a servlet showing the value of our EJB counter for the current HTTP session.</p>\n<p>Here comes the tricky part; one might think to:</p>\n<ul>\n<li>employ <code class=\"language-text\">@EJB</code> to locally or remotely inject the bean into the servlet</li>\n<li>resolve the EJB by instantiating <strong>InitialContext</strong> in the <strong>doGet()</strong> servlet method and consequently call <strong>lookup()</strong></li>\n</ul>\n<p>Unfortunately, neither of the above methods will work correctly.</p>\n<p>The 2 simplest solutions are perhaps:</p>\n<ol>\n<li>\n<p>Employ a proxy <em>CDI bean</em>:</p>\n<ol>\n<li>Create a <code class=\"language-text\">@SessionScoped</code> CDI bean <em>in the web project</em> - named, for example, <strong>CounterClient</strong></li>\n<li>Inject the counter EJB into it - via <code class=\"language-text\">@Inject</code> or <code class=\"language-text\">@EJB</code> - in order to keep the reference to the counter EJB for the life of the HTTP session</li>\n<li>Inject <strong>CounterClient</strong> (via <code class=\"language-text\">@Inject</code>) into the servlet</li>\n</ol>\n<p>The advantages of such approach are:</p>\n<ul>\n<li>you do not need to perform explicit lookups if the web tier is in the same <strong>ear</strong> as the EJB tier - thus supporting local injection</li>\n<li>the client bean can add logic to simplify the interface of the wrapped EJB - or it can just expose the original bean via a getter, or introduce a mixed approach</li>\n<li>finally, by using <code class=\"language-text\">@Named</code>, you can easily integrate it into other technologies, such as Java Server Faces.</li>\n</ul>\n</li>\n<li>Call HttpSession's <strong>getAttribute()</strong> method to retrieve the EJB handle, looking it up via <strong>InitialContext</strong> only if it was not found. A drawback is that such approach would require an explicit naming operation even for resolving a local interface.</li>\n</ol>\n<h4>Reference files</h4>\n<ul>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-war/src/main/scala/info/gianlucacosta/clustering/magellan/web/counter/CounterClient.scala\">CounterClient</a></li>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-war/src/main/scala/info/gianlucacosta/clustering/magellan/web/counter/CounterServlet.scala\">CounterServlet</a></li>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-war/src/main/scala/info/gianlucacosta/clustering/magellan/web/counter/ResetCounterServlet.scala\">ResetCounterServlet</a></li>\n</ul>\n<h2>Testing the web-EJB connection</h2>\n<p>Once again, we can employ our load balancer, and run:</p>\n<ul>\n<li><a href=\"http://localhost:8080/magellan/counter\">http://localhost:8080/magellan/counter</a> to see the ever-increasing value of the counter bean</li>\n<li><a href=\"http://localhost:8080/magellan/counter/reset\">http://localhost:8080/magellan/counter/reset</a> to reset its value</li>\n</ul>\n<p>By alternately shutting down the server instances like we did for the session servlet, we can test state replication for our bean.</p>\n<h2>The ScalaFX client</h2>\n<p>What if we want to access a stateful EJB from a <em>rich UI client</em>? In this example, a ScalaFX app will call the methods exposed by the <em>counter</em> EJB - with each execution of the app referencing a different bean instance.</p>\n<p>ScalaFX is a simple and elegant library providing Scala bindings and new syntax constructs for the modern JavaFX GUI toolkit.</p>\n<p>The suggested way to run the example is <a href=\"https://github.com/giancosta86/moondeploy\">MoonDeploy</a>, an open source deployment tool similar to Java Web Start: if MoonDeploy is installed, just click on <strong>App.moondeploy</strong> in Magellan's <a href=\"https://github.com/giancosta86/magellan/releases/latest\">latest release</a> file list and open it with MoonDeploy - the application will be downloaded and started.</p>\n<p>By clicking on the two buttons shown in the JavaFX user interface, you'll actually interact with the session bean on the server.</p>\n<h2>Highlights of the ScalaFX client</h2>\n<p>The core of the program is the interaction with the stateful EJB - which is <strong>not</strong> a standard, portable process; in the case of WildFly, a few basic steps are required:</p>\n<ol>\n<li>Reference <strong>org.wildfly:wildfly-ejb-client-bom:WILDFLY_VERSION</strong> as a dependency in the Gradle build script - where <strong>WILDFLY_VERSION</strong> could be, for example, <strong>9.0.2.Final</strong></li>\n<li>Reference the <strong>client interface library</strong> provided by the EJB developer - in this case, as the Gradle projects share the same root project, we just employed <code class=\"language-text\">project(&quot;:magellan-common&quot;)</code></li>\n<li>\n<p>Perform an <em>almost</em> standard JNDI lookup:</p>\n<ol>\n<li>Instantiate an <strong>InitialContext</strong> with no constructor parameters</li>\n<li>\n<p>Call its <strong>lookup()</strong> method, passing the portable JNDI name <em>without the</em> <strong>java:global/</strong> <em>prefix</em>, then casting the result to the remote interface; in the example, the reduced JNDI name is:</p>\n<p><strong>Magellan/magellan-ejb/CounterBean!info.gianlucacosta.clustering.magellan.ejb.CounterRemote</strong></p>\n</li>\n</ol>\n<p>  whose components are:</p>\n<ul>\n<li><strong>App name</strong>: <em>Magellan</em></li>\n<li><strong>Module name</strong>: <em>magellan-ejb</em></li>\n<li><strong>Bean name</strong>: <em>CounterBean</em></li>\n<li><strong>FQN of the referenced interface</strong>: <em>info.gianlucacosta.clustering.magellan.ejb.CounterRemote</em></li>\n<li>Just call the methods of the remote interface, as if it were a local object</li>\n</ul>\n</li>\n<li>Create a <strong>jndi.properties</strong> file in <strong>src/main/resources</strong>, required to correctly instantiate the <strong>InitialContext</strong> in the above steps; alternatively, you might choose to pass a <em>Hashtable</em> to <em>InitialContext</em>'s constructor, especially in case of dynamic parameters.</li>\n<li>\n<p><strong>jndi.properties</strong> must include at least the following lines:</p>\n<ul>\n<li><strong>java.naming.factory.initial</strong>=<em>org.jboss.naming.remote.client.InitialContextFactory</em>\nto declare the provider employed by JNDI so as to connect to the server</li>\n<li><strong>java.naming.provider.url</strong>=<em>http-remoting://localhost:8081,http-remoting://localhost:8082</em>\na comma-separated list of nodes in the cluster used for connecting to the cluster.\nWe are passing the explicit list of addresses because our load balancer handles HTTP interactions - which is not the case of the rich client</li>\n<li><strong>jboss.naming.client.ejb.context</strong>=<strong>true</strong>\nmandatory when you perform an EJB lookup</li>\n</ul>\n</li>\n</ol>\n<h4>Reference files</h4>\n<ul>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-app-client/src/main/resources/jndi.properties\">jndi-properties</a></li>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-app-client/src/main/scala/info/gianlucacosta/clustering/magellan/appclient/App.scala\">App</a></li>\n<li><a href=\"https://github.com/giancosta86/magellan/blob/master/magellan-app-client/src/main/scala/info/gianlucacosta/clustering/magellan/appclient/CounterBeanService.scala\">CounterBeanService</a></li>\n</ul>\n<h2>Conclusion</h2>\n<p>Well, it seems we have covered quite a bit of ground! ^__^ I really hope you have found this brief tutorial a helpful starting point for learning more about clustering, load balancing and the world of Java EE in general - especially with <strong>WildFly</strong>, <strong>Gradle</strong> and the <strong>Scala</strong> programming language! ^__^</p>\n<h2>Further references</h2>\n<ul>\n<li><a href=\"https://github.com/giancosta86/magellan\">Magellan project page on GitHUb</a></li>\n<li><a href=\"https://docs.jboss.org/author/display/WFLY8/High+Availability+Guide\">WildFly - High Availability Guide</a></li>\n<li><a href=\"https://docs.jboss.org/author/display/WFLY8/Operating+modes\">WildFly - Operating modes</a></li>\n<li><a href=\"https://docs.jboss.org/author/display/WFLY8/Load+Balanced+HA+Standalone+Cluster+-+Howto\">WildFly - Load Balanced HA Standalone Cluster - Howto</a></li>\n<li><a href=\"http://lia.deis.unibo.it/Courses/sd1516-info/lucidi/11-clustering%281x%29.pdf\">Clustering di Applicazioni in JBoss - Professor Paolo Bellavista</a></li>\n<li><a href=\"https://docs.jboss.org/author/display/WFLY8/Remote+EJB+invocations+via+JNDI+-+EJB+client+API+or+remote-naming+project\">WildFly - Remote EJB invocations via JNDI - EJB client API or remote-naming project</a></li>\n<li><a href=\"http://wildfly.org/\">WildFly</a></li>\n<li><a href=\"http://docs.oracle.com/javaee/\">Java EE</a></li>\n<li><a href=\"http://scala-lang.org/\">Scala</a></li>\n<li><a href=\"http://www.scalafx.org/\">ScalaFX</a></li>\n<li><a href=\"http://docs.oracle.com/javase/tutorial/jndi/index.html\">JNDI</a></li>\n<li><a href=\"https://github.com/giancosta86/moondeploy\">MoonDeploy</a></li>\n</ul>"}},"pageContext":{"nodeId":"9accc941-3ac9-51ae-b6c8-98d40a73e097"}},"staticQueryHashes":["3159585216","3567824559"]}